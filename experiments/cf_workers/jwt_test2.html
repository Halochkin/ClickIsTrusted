<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
hello
<script type="module">
  (async function () {

    // String (UCS-2) to Uint8Array
    //
    // because... JavaScript, Strings, and Buffers
    function strToUint8(str) {
      return new TextEncoder().encode(str);
    }

    // UCS-2 String to URL-Safe Base64
    //
    // btoa doesn't work on UTF-8 strings
    // Because JavaScript has a strange relationship with strings
    // https://coolaj86.com/articles/base64-unicode-utf-8-javascript-and-you/
    function strToUrlBase64(str) {
      str = encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode(parseInt(p1, 16)));
      return binToUrlBase64(str);
    }

    // Binary String to URL-Safe Base64
    //
    // btoa (Binary-to-Ascii) means "binary string" to base64
    function binToUrlBase64(bin) {
      return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+/g, '');
    }

    // Uint8Array to URL Safe Base64
    //
    // the shortest distant between two encodings... binary string
    function arrayBufferUint8ToUrlBase64(buffer) {
      const uint8 = new Uint8Array(buffer);
      var bin = '';
      uint8.forEach(function (code) {
        bin += String.fromCharCode(code);
      });
      return binToUrlBase64(bin);
    }

    async function ECgenerate() {
      const k = await window.crypto.subtle.generateKey({name: 'ECDSA', namedCurve: 'P-256'}, true, ['sign', 'verify']);
      // returns an abstract and opaque WebCrypto object,
      // which in most cases you'll want to export as JSON to be able to save
      return await window.crypto.subtle.exportKey('jwk', k.privateKey);
    }

    // Create a Public Key from a Private Key
    //
    // chops off the private parts
    function ECneuter(jwk) {
      var copy = Object.assign({}, jwk);
      delete copy.d;
      copy.key_ops = ['verify'];
      return copy;
    }

    const jwk = await ECgenerate();
    console.info('Private Key:', JSON.stringify(jwk));
    console.info('Public Key:', JSON.stringify(ECneuter(jwk)));
    const keyType = {
      name: 'ECDSA',
      namedCurve: 'P-256',
      hash: {name: 'SHA-256'}
    };





    async function JWKthumbprint(jwk) {
      // lexigraphically sorted, no spaces
      // The hash should match the size of the key,
      // but we're only dealing with P-256
      var sortedPub = JSON.stringify({'crv': jwk.crv, "kty": "EC", 'x': jwk.x, 'y': jwk.y,}, null, 0);
      const hash = await window.crypto.subtle.digest({name: 'SHA-256'}, strToUint8(sortedPub));
      return arrayBufferUint8ToUrlBase64(hash);
    }

    const header = {
      typ: 'JWT',
      alg: 'ES256',
      kid: await JWKthumbprint(jwk)
    };

    var payload = {
      iss: 'https://example.com/',
      sub: 'xxx',
      // azp: 'https://cool.io/',
      // jti: 'YNiXjHAmoehN8TsIgkvr1g',  // An arbitrary (probably random) id for the token
      aud: 'https://example.com/',
      exp: Math.round(Date.now() / 1000) + 15 * 60
    };

    async function JWTsign(jwk, headers, claims, keyType) {
      // The headers should probably be empty

      const base64urlJsonHeader = strToUrlBase64(JSON.stringify(headers));
      const base64urlJsonPayload = strToUrlBase64(JSON.stringify(claims));

      // Actually do the import, which comes out as an abstract key type
      const privkey = await window.crypto.subtle.importKey('jwk', jwk, keyType, true, ['sign']);
      // Convert UTF-8 to Uint8Array ArrayBuffer
      var data = strToUint8(base64urlJsonHeader + '.' + base64urlJsonPayload);

      // The signature and hash should match the bit-entropy of the key
      // https://tools.ietf.org/html/rfc7518#section-3
      const signature = await window.crypto.subtle.sign(keyType, privkey, data);
      // returns an ArrayBuffer containing a JOSE (not X509) signature,
      // which must be converted to Uint8 to be useful
      const base64UrlSignature = arrayBufferUint8ToUrlBase64(signature);

      // JWT is just a "compressed", "protected" JWS
      return base64urlJsonHeader + '.' + base64urlJsonPayload + '.' + base64UrlSignature;
    }

    const jwtString = await JWTsign(jwk, header, payload, keyType);
    console.info('JWT:', jwtString);
  })();

</script>
</body>
</html>