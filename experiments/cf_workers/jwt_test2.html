<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
hello
<script type="module">
  (async function () {

    // String (UCS-2) to Uint8Array
    //
    // because... JavaScript, Strings, and Buffers
    function strToUint8(str) {
      return new TextEncoder().encode(str);
    }

    // UCS-2 String to URL-Safe Base64
    //
    // btoa doesn't work on UTF-8 strings
    function strToUrlBase64(str) {
      return binToUrlBase64(utf8ToBinaryString(str));
    }

    // Binary String to URL-Safe Base64
    //
    // btoa (Binary-to-Ascii) means "binary string" to base64
    function binToUrlBase64(bin) {
      return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+/g, '');
    }

    // UTF-8 to Binary String
    //
    // Because JavaScript has a strange relationship with strings
    // https://coolaj86.com/articles/base64-unicode-utf-8-javascript-and-you/
    function utf8ToBinaryString(str) {
      // replaces any uri escape sequence, such as %0A,
      // with binary escape, such as 0x0A
      return encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode(parseInt(p1, 16)));
    }

    // Uint8Array to URL Safe Base64
    //
    // the shortest distant between two encodings... binary string
    function uint8ToUrlBase64(uint8) {
      var bin = '';
      uint8.forEach(function (code) {
        bin += String.fromCharCode(code);
      });
      return binToUrlBase64(bin);
    }

    async function ECgenerate() {
      const k = await window.crypto.subtle.generateKey({name: 'ECDSA', namedCurve: 'P-256'}, true, ['sign', 'verify']);
      // returns an abstract and opaque WebCrypto object,
      // which in most cases you'll want to export as JSON to be able to save
      return await window.crypto.subtle.exportKey('jwk', k.privateKey);
    }

    // Create a Public Key from a Private Key
    //
    // chops off the private parts
    function ECneuter(jwk) {
      var copy = Object.assign({}, jwk);
      delete copy.d;
      copy.key_ops = ['verify'];
      return copy;
    }

    const jwk = await ECgenerate();
    console.info('Private Key:', JSON.stringify(jwk));
    console.info('Public Key:', JSON.stringify(ECneuter(jwk)));





    async function JWTsign(jwk, headers, claims) {
      // The headers should probably be empty

      const base64urlJsonHeader = strToUrlBase64(JSON.stringify(headers));
      const base64urlJsonPayload = strToUrlBase64(JSON.stringify(claims));

      // To import as EC (ECDSA, P-256, SHA-256, ES256)
      var keyType = {
        name: 'ECDSA',
        namedCurve: 'P-256',
        hash: {name: 'SHA-256'}
      };

      // Actually do the import, which comes out as an abstract key type
      const privkey = await window.crypto.subtle.importKey('jwk', jwk, keyType, true, ['sign']);
      // Convert UTF-8 to Uint8Array ArrayBuffer
      var data = strToUint8(base64urlJsonHeader + '.' + base64urlJsonPayload);

      // The signature and hash should match the bit-entropy of the key
      // https://tools.ietf.org/html/rfc7518#section-3
      const signature = await window.crypto.subtle.sign({name: 'ECDSA', hash: {name: 'SHA-256'}}, privkey, data);
      // returns an ArrayBuffer containing a JOSE (not X509) signature,
      // which must be converted to Uint8 to be useful
      const base64UrlSignature = uint8ToUrlBase64(new Uint8Array(signature));

      // JWT is just a "compressed", "protected" JWS
      return base64urlJsonHeader + '.' + base64urlJsonPayload + '.' + base64UrlSignature;
    }

    async function JWKthumbprint(jwk) {
      // lexigraphically sorted, no spaces
      // The hash should match the size of the key,
      // but we're only dealing with P-256
      var sortedPub = JSON.stringify({'crv': jwk.crv, "kty": "EC", 'x': jwk.x, 'y': jwk.y,}, null, 0);
      const hash = await window.crypto.subtle.digest({name: 'SHA-256'}, strToUint8(sortedPub));
      return uint8ToUrlBase64(new Uint8Array(hash));
    }

    const header = {
      typ: 'JWT',
      alg: 'ES256',
      kid: await JWKthumbprint(jwk)
    };
    var payload = {
      iss: 'https://example.com/',
      sub: 'xxx',
      // azp: 'https://cool.io/',
      // jti: 'YNiXjHAmoehN8TsIgkvr1g',  // An arbitrary (probably random) id for the token
      aud: 'https://example.com/',
      exp: Math.round(Date.now() / 1000) + 15 * 60
    };

    const jwtString = await JWTsign(jwk, header, payload);
    console.info('JWT:', jwtString);
  })();

</script>
</body>
</html>